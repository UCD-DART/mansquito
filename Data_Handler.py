# # # Mansquito Data Handler # # #
"""
This script is used to create graphs and reformat mosquito count data generated by the Salt Lake City Mosquito Abatement
District Surveillance Program. The primary function of this program is using count data to create bar graphs showing
total abundance per trap site. Additionally, the program is able to convert trap data from its current format into
differently formatted Excel files which can then be used to upload data to VectorSurv, Tableau, or the ArcGIS dashboard.

# Required files #
# # Mosquito Count Graphs 2020.xlsx # #
Count data is stored in an .xlsx file. This file contains 4 worksheets: CO2 Data, Gravid Data, City CO2 Data, and
BGS Data. For each worksheet, the columns begin with 'date', 'location', 'total', and 'problems'. Following these first
four columns, a series of mosquito species are listed in the format, 'genus_species_f' (or 'genus_species_m' for males).
The final column is labeled 'comments'. The Gravid Data worksheet has a column, 'total_culex_f', which follows the
'comments' column.  The 'comments' column (or 'total_culex_f') is the final column that is read by this script, although
other information is often stored in subsequent columns.

The 'date' column is automatically formatted by Excel to mm/dd/yyyy. Location names must be in order and spelled
correctly. 'total' is the total estimated by ImageJ or the hand count for traps <300. The 'problems' column
is checked for text. If the text says 'not set' then the trap will be marked as not set on the graph. Any other text
will cause the trap to be marked as a trap failure. The species columns contain the number of that species within the
subsample, not the entire trap. Therefore, the total column will usually read much higher than if all the species
columns were summed. The 'comments' column can be used to override the 'problems' column by starting the entry with
'text:'. This is useful if you want to specify on the graph that a trap was a partial failure, was set on a different
day, etc.

# # chromedriver.exe # #
ChromeDriver is used to access the internet for weather scrapes. It may need to be periodically updated. To do so, go to
https://chromedriver.chromium.org/downloads and download the version which matches the current version of Chrome. (To
check the version of Chrome, go to Settings, then select About Chrome from the sidebar.) After downloading, unzip the
file and place it in the same folder as the script.

# # weather.csv # #
Weather data is scraped from Weather Underground and saved in a .csv file called 'weather.csv'. The file contains
'date', 'high', 'low', 'precip', and 'wind' columns. 'date' will be automatically formatted by Excel.'high' and 'low'
are the temperatures in F. 'precip' and 'wind' hold either a 0 or 1 indicating whether or not it was rainy or windy
respectively. If the webscraper ever breaks, this file can be updated by hand. Be sure to save as a .csv file.

# # weather icons # #
To render weather icons on the graphs, a 'wind.png' and 'rain.png' must be in the script directory. 'wind.png' is 15x11
and 'rain.png' is 10x12.

# # aerial_blocks.csv # #
This file holds the name of a spray block and the sites that are within that spray block. The top row lists the name of
the spray block. The subsequent rows list the sites included in that block. Spelling of site names must match this
script.

# # sprays.csv # #
This file contains the record of actual sprays. The first column 'trap_date' is the date for which you would like the
spray arrows to be drawn on (e.g. if the spray happened on 6/3/2020, the arrows would be drawn onto the traps set the
next night on 6/4/2020). The next column, 'block', is the name of the block that was sprayed. This must correspond to a
block in the aerial_sprays.csv. The last column is 'spray_date'. This column is only for human reference to know what
date the spray occured (as opposed to the date of the next trap night).

# Graphs #
# # CO2 # #
CO2 graphs are bar graphs which display the total species abundance per trap site. Four graphs are created each week,
two preliminary graphs and two final graphs. The preliminary graphs only show trap sites where the total count exceeded
300 mosquitoes, the threshold for treatment. The final graph shows all trap sites. The first prelim/final graph pair
shows the data gathered on Monday night. The second pair of graphs shows the data for Monday night and Wednesday night
side by side. However, this script will also support side-by-side comparisons of any two nights.

In addition to count data, the CO2 graphs also display a legend showing the temperature for the trap nights and small
icons indicating whether it was windy or rainy. If an aerial spray was performed, arrows indicating which sites were
sprayed may also be rendered on the graph. Weather data is scraped from web, and aerial spray data is saved in a pair of
.csv files (aerial_blocks.csv and sprays.csv, described above).

# # Gravid # #
Gravid trap graphs show total Culex abundance per trap site. Each graph shows data for each site for the last 3 trap
nights. As with the CO2 graphs, it can be any 3 nights though. There are two separate gravid routes, one set on Monday
and one set on Wednesday. Weather data is collected and displayed by the same function as the CO2 graphs.

# # City CO2 and BGS # #
City CO2 and BGS graphs are stacked bar graphs showing total abundance as well as species composition. This function is
still unpolished and is not often utilized since the information is redundant to the Tableau maps. Previously, the maps
could only be made after data was uploaded to VectorSurv and then accessed from the VectorSurv server via Tableau,
creating a day long delay since VectorSurv data is only pushed to the server every 24 hours. The stacked graphs were
used to present the data in the interim. However, since data can now be passed directly to Tableau, these graphs are now
unnecessary most of the time.

# Data Formatting Functions #
The other three major functions, andrive(), vecsurv(), and tableau() simply take the data and save it in a different
arrangement as a .csv file. For example, the andrive function adds GPS coordinates for each trap site so that the
species data can be displayed geographically on the ArcGIS dashboard in the conference room. The specific
transformations are documented within each of the functions.
"""
# Christian Weinrich 2020
import datetime
import pandas as pd
import numpy as np
import csv
from openpyxl import load_workbook
from selenium import webdriver
import matplotlib.pyplot as plt
import matplotlib.image
from matplotlib.offsetbox import OffsetImage, AnnotationBbox
from matplotlib import transforms
from PIL import Image

# greet the user and prepare files
print('\nWelcome to the Mansquito Data Handler!\n')
valid_input = False
while valid_input is False:
    y = input('Enter the year:\n')
    try:
        year = int(y)
        valid_input = True
    except ValueError:
        print('Invalid input. Please enter the year as an integer.')

# # # file parameters # # #
mosquito_count = '{}/Mosquito Count Graphs {}.xlsx'.format(year, year)  # count data file
vecsurv_out_directory = '{}/VectorSurv Import Forms/vectorsurv_'.format(year)
andrive_out_csv = 'TrapLocationDashboard.csv'
graph_pdf_directory = '{}/Weekly Graph PDFs/CO2/'.format(year)
gravid_graph_pdf_directory = '{}/Weekly Graph PDFs/Gravid/'.format(year)
city_graph_pdf_directory = '{}/Weekly Graph PDFs/City CO2/'.format(year)

# read site information from 'trap_sites.csv'
ID = {}
coords = {}
sites = []
mon_sites = []  # Monday gravids
wed_sites = []  # Wednesday gravids
city_sites = []
bgs_ind_sites = []  # industrial BGS sites
bgs_city_sites = []  # city BGS sites

mon_ticks = []  # list of gravid sites with addresses (for x ticks on graphs)
wed_ticks = []  # list of gravid sites with addresses (for x ticks on graphs)
city_ticks = []  # list of city sites with addresses (for x ticks on graphs)

with open('trap_sites.csv', 'r', newline='') as file:
    reader = csv.DictReader(file)
    for row in reader:
        ID[row['site']] = row['id']
        coords[row['site']] = [row['long'], row['lat']]
        if row['co2'] == 'X':
            sites.append(row['site'])
        if row['mon'] == 'X':
            mon_sites.append(row['site'])
            if row['address'] != '':
                mon_ticks.append(f"{row['site']}\n{row['address']}")
            else:
                mon_ticks.append(row['site'])
        if row['wed'] == 'X':
            wed_sites.append(row['site'])
            if row['address'] != '':
                wed_ticks.append(f"{row['site']}\n{row['address']}")
            else:
                wed_ticks.append(row['site'])
        if row['city'] == 'X':
            city_sites.append(row['site'])
        if row['bgs_ind'] == 'X':
            bgs_ind_sites.append(row['site'])
        if row['bgs_city'] == 'X':
            bgs_city_sites.append(row['site'])


# # # functions # # #
def get_month(prompt='Enter month:\n'):
    """
    Ask the user to input the month as an integer. Ask again if input is invalid.
    """
    valid_input = False
    while valid_input is False:
        m = input(prompt)
        try:
            month = int(m)
            if 1 <= month <= 12:
                valid_input = True
            else:
                print('Invalid input. Month must be between 1 and 12.')
        except ValueError:
            print('Invalid input. Please enter month as an integer.')
    return month


def get_day(prompt='Enter day:\n'):
    """
    Ask the user to input the day as an integer. Ask again if input is invalid.
    """
    valid_input = False
    while valid_input is False:
        d = input(prompt)
        try:
            day = int(d)
            if 1 <= day <= 31:
                valid_input = True
            else:
                print('Invalid input. Day must be between 1 and 31.')
        except ValueError:
            print('Invalid input. Please enter day as an integer.')
    return day


def get_int(prompt, min, max):
    """
    Ask the user to input an integer between min and max. Ask again if input is invalid.
    """
    valid_input = False
    while valid_input is False:
        i = input(prompt)
        try:
            inti = int(i)
            if min <= inti <= max:
                valid_input = True
            else:
                print('Invalid input. Selection must be between {} and {}.'.format(str(min), str(max)))
        except ValueError:
            print('Invalid input. Please enter an integer.')
    return inti


def get_xy(prompt, x='y', y='n'):
    """
    Ask the user to input x or y. Ask again if input is invalid.

    Usually used for a yes/no input, but this function is used once in make_gravid_graph() to ask for 'm' (Monday) or
    'w' (Wednesday).
    """
    valid_input = False
    while valid_input is False:
        a = input(prompt)
        if len(a) == 1:
            if a == x or a == y:
                valid_input = True
            else:
                print("Invalid input. Please enter '{}' or '{}'.".format(x, y))
        else:
            print('Invalid input. Please enter a single character.')
    return a


def get_weather(month, day, year=year):
    """
    Look for weather data saved in the weather.csv file from previous scrapes.
    If data is not found for the given date, scrape weather data from Weather Undergound.

    Return weather data as a dictionary.
    """
    date = datetime.date(year=int(year), month=int(month), day=int(day))
    datestring = date.strftime('%#m/%#d/%Y')  # this is the default date format for excel
    with open('weather.csv') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            if row['date'] == datestring:
                print('{}: Weather found.'.format(datestring))
                weather = {'high': int(row['high']), 'low': int(row['low']),
                           'precip': int(row['precip']), 'wind': int(row['wind'])}
                return weather
    # if weather data not in weather.csv, call weather_scrape()
    print('{}: Weather not found. Scraping from Weather Underground...'.format(datestring))
    weather = weather_scrape(month, day)
    return weather


def weather_scrape(month, day, year=year):
    """
    Scrape Weather Underground for weather of the given date.
    Save weather data to weather.csv.

    Return weather data as a dictionary.
    """

    # create the URL for weather of the specified date
    date = datetime.date(year=int(year), month=int(month), day=int(day))
    base_url = 'https://www.wunderground.com/history/daily/us/ut/salt-lake-city/KSLC/date/'
    url = base_url + date.strftime('%Y-%#m-%#d')

    # use Google Chrome driver to open HTML
    driver = webdriver.Chrome()
    driver.implicitly_wait(40)  # tell the driver to wait for the page to load
    driver.get(url)

    # find all HTML elements on the page with <td> tag (td==table data)
    results = driver.find_elements_by_tag_name("td")
    table_data = []


    # access the data in each <td> element
    # add element to 'table_data' list if the data can be converted to decimal number
    for result in results:
        td = result.get_attribute('innerHTML')
        try:
            table_data.append(float(td))
        except ValueError:
            continue

    # since the page is loaded with a predictable format,
    # we can find high,low, and precip. info of interest by simply accessing the correct list index
    high = int(table_data[0])
    low = int(table_data[3])
    # precip is saved as 0 or 1 indicating 'no rain' or 'yes rain' since precip. amount is not important
    if table_data[8] > 0:
        precip = 1
    else:
        precip = 0
    weather = {'high': high, 'low': low, 'precip': precip}

    # wind is only important if the speeds exceed 10mph after 6pm
    winds = []
    # access table containing wind data and find wind speed/time pairs
    pd_tables = driver.find_elements_by_class_name("mat-table.cdk-table.mat-sort.ng-star-inserted")
    for table in pd_tables:
        new_table = pd.read_html(table.get_attribute('outerHTML'))
        if new_table:
            df = pd.concat(new_table)
            for row in range(24):  # one measurement taken once an hour => 24 rows per day
                w = df.at[row, 'Wind Speed']
                t = df.at[row, 'Time']
                if isinstance(t, float):
                    break
                time = datetime.datetime.strptime(t, '%I:%M %p')  # convert t from string to datetime.time
                if time >= time.replace(hour=18):  # if time is past 6pm, add wind speed to wind
                    winds.append(int(w.rstrip(' °mph')))
    # as with precip, wind is either 0 or 1 indicating 'no wind over 10mph' or 'yes wind over 10mph'
    if max(winds) >= 10:
        wind = 1
    else:
        wind = 0
    print('Weather scrape completed.')
    weather['wind'] = wind

    # open weather.csv and save data collected from scrape
    with open('weather.csv', 'a', newline='') as csvfile:
        fieldnames = ['date', 'high', 'low', 'precip', 'wind']
        new_row = weather
        new_row['date'] = date.strftime('%#m/%#d/%Y')  # this format is the excel default
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writerow(new_row)

    driver.quit()
    return weather


def make_graph(year=year):
    """
    This function creates CO2 graphs showing abundance per trap site, weather and aerial spray locations (optional).
    Graphs can display data for one day or two separate days side-by-side. Graphs can either be preliminary, which only
    display traps that exceeded 300 total mosquitoes, or final, which show all traps for the given date.

    Finished graphs are saved as 'most_recent.jpg' and then displayed to user upon completion. The user may then decide
    to save the graph as a .pdf and/or save a copy of the .jpg to the Google Drive used by the ArcGIS dashboard.

    The additional files required are described at the top of the script.
    """

    # # # sub-functions # # #
    global note_text

    def get_spray(date):
        """
        Look for spray block records in sprays.csv.
        Return sprayed sites as a list (or an empty list if no spray blocks for that date were found).
        """
        sprays = []
        sites_sprayed = []
        datestring = date.strftime('%#m/%#d/%Y')
        # look for spray block name for the given date
        with open('sprays.csv', newline='') as csvfile:
            reader = csv.reader(csvfile)
            for row in reader:
                if row[0] == datestring:
                    sprays.append(row[1])
                    date_of_spray = str(row[2])


        # convert block(s) to list(s) of sites by referencing aerial_blocks.csv
        if sprays:
            for spray in sprays:
                print(datestring + ': Spray found. ' + spray)
                with open('aerial_blocks.csv', 'r', newline='') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        if row[spray] != '':
                            sites_sprayed.append(row[spray])
        else:
            print(datestring + ': No aerial application record found')
        return sites_sprayed

    def read_to_series(row, date, series, spray_y, problems, com_index):
        """
        Function for iterating through count data and adding relevant data to 'series' and 'problems' for graphing.22021

        """
        # if date in count sheet matches, add the total count to series
        if row[0] == date:
            if row[2] is None:  # row[2] is 'total' column for that trap night
                y = 0
            else:
                y = row[2]
            series.append(y)

            # if a site was sprayed, but had <300 mosquitoes, the arrow will not be shown on prelim graph
            # adjust spray_y value so that spray arrows will be drawn at y=300 if the graph is prelim to avoid this
            if pre == 'y' and y < 300:
                y = 300
            spray_y[row[1]] = y

            # if trap failed or wasn't set, add text to 'problems' list saying so
            # row[com_index] == 'comments' column, row[3] == 'problems' column
            if row[com_index] is not None and row[com_index].startswith('text:') is True:
                problems.append({'x': row[1], 'y': y, 'text': row[com_index].replace('text:', '')})
            elif row[3] == 'not set':
                problems.append({'x': row[1], 'y': y, 'text': 'Not Set'})
            elif row[3] is not None:
                problems.append({'x': row[1], 'y': y, 'text': 'Trap Failure'})

    def weather_icon(icon, column, row):
        """
        Draws the icon to the weather legend at (column, row).
        """
        imagebox = OffsetImage((matplotlib.image.imread(icon + '.png')), zoom=0.5)
        c = {'A': 1.0152, 'B': 1.028}
        r = {1: 0.408, 2: 0.375}
        ab = AnnotationBbox(imagebox, (c[column], r[row]), xycoords='axes fraction', frameon=False)
        ax.add_artist(ab)

    def rainbow_text(x, y, ls, lc, **kw):
        """
        Take list of strings (ls) and list of colors (lc), and render each strings as the corresponding color.

        x,y should be in axes fraction coords
        """
        t = plt.gca().transData
        fig = plt.gcf()
        data_to_axis = ax.transAxes + ax.transData.inverted()
        new_xy = data_to_axis.transform([x, y]).tolist()
        x, y = new_xy[0], new_xy[1]
        # horizontal version
        for s, c in zip(ls, lc):
            text = plt.text(x, y, " " + s + " ", color=c, transform=t,
                            verticalalignment='top', horizontalalignment='left', **kw)
            text.draw(fig.canvas.get_renderer())
            ex = text.get_window_extent()
            t = transforms.offset_copy(text._transform, y=-ex.height * 13.5, units='dots')

    # set up initial variables #
    year = year
    # open a read-only .xlsx workbook as the source of input data
    wb = load_workbook(filename=mosquito_count, data_only=True, read_only=True)
    ws = wb['CO2 Data']
    series1 = []  # holds the count numbers
    series2 = []
    problems1 = []  # holds sites where the trap failed or wasn't set
    problems2 = []
    spray_sites1 = []  # holds sites that were sprayed
    spray_sites2 = []
    spray_y1 = {}  # holds sites where spray arrow height has to be adjusted to appear on prelim graph
    spray_y2 = {}
    draw_spray = False

    # ask user to specify what type of graph to make and for which date(s)
    if get_xy('Draw spray arrows? y/n\n') == 'y':
        draw_spray = True

    pre = get_xy('Will this be a preliminary graph? y/n\n')

    two_days = get_xy('Will this be a graph of two days? y/n\n')
    if two_days == 'y':
        month1 = get_month("Enter first month:\n")
        day1 = get_day("Enter first day:\n")
        date1 = datetime.datetime(int(year), int(month1), int(day1))
        month2 = get_month("Enter second month:\n")
        day2 = get_day("Enter second day\n")
        date2 = datetime.datetime(int(year), int(month2), int(day2))
        if draw_spray == True:
            spray_sites1 = get_spray(date1)
            spray_sites2 = get_spray(date2)

    elif two_days == 'n':
        month1 = get_month()
        day1 = get_day()
        date1 = datetime.datetime(int(year), int(month1), int(day1))
        if draw_spray == True:
            spray_sites1 = get_spray(date1)

    # option to add an annotation with additional notes.
    note = get_xy('\nAdd a note? y/n\n')
    note_y = 0.19
    if note == 'y':
        note_in = input('Enter your note:\n')
        note_text = ""
        break_length = 24
        breaks = (len(note_in) // break_length) + 1
        for i in range(breaks):
            note_text += (note_in[:break_length] + '\n')
            note_in = note_in[break_length:]
            note_y -= 0.025
        note_text = note_text[:-1]

    # begin defining graph parameters
    matplotlib.rcParams['font.family'] = 'serif'
    matplotlib.rcParams['font.size'] = 7
    x = (np.arange(len(sites)))
    plt.figure(figsize=(10, 5), dpi=100)
    ax = plt.subplot()
    # gridlines
    ax.set_axisbelow(True)  # draw gridlines under bars
    ax.yaxis.grid(True, which='both', color='grey', alpha=.25)

    # find which column in count sheet contains 'comments' (currently 16, but will change if species columns are added)
    # allows comments to be rendered on graph with 'text:'
    for i in range(30):
        if ws.cell(row=1, column=i+1).value == 'comments':  # ws.cell() starts index at 1, hence i+1 (yuck)
            com_index = i  # but index of 'row' in ws.iter_rows() below starts at 0

    # iterate over rows in workbook to find dates of interest
    # then add count values to 'series' lists if matched
    for row in ws.iter_rows(min_row=2, max_col=30, max_row=10000, values_only=True):
        read_to_series(row, date1, series1, spray_y1, problems1, com_index)
        if two_days == 'y':
            read_to_series(row, date2, series2, spray_y2, problems2, com_index)

    # turn series lists in bar graphs
    width = 0.7
    if two_days == 'n':
        rect1 = ax.bar(x, series1, width, label=date1.strftime("%d-%b-%Y"), color='blue')
    elif two_days == 'y':
        width = 0.35
        rect1 = ax.bar(x - width / 2, series1, width, label=date1.strftime("%d-%b-%Y"), color='blue')
        rect2 = ax.bar(x + width / 2, series2, width, label=date2.strftime("%d-%b-%Y"), color='red')

    # label x axis & ticks
    ax.set_xticks(x)
    ax.set_xticklabels(sites, rotation=45, ha='right')
    tick_dict = {}
    for i in range(len(sites)):
        tick_dict[sites[i]] = x[i]

    # label y axis
    plt.ylabel('No. female mosquitoes trapped', fontweight='bold')

    # if prelim graph, set y axis minimum to 300, add tick label at 300 and create aesthetic intervals for gridlines
    data_max = round((max(series1 + series2))/100)*100  # find the largest trap count and round it to nearest 100
    interval = round((data_max/1000))*100  # find 10% of data_max and round to nearest 100
    if pre == 'y':
        ax.set_ylim(ymin=300)
        yt = [300]
        for i in np.arange(300, data_max + interval, interval):
            yt.append(i)
        plt.yticks(yt)
        data_max -= 300

    # add 'not set' and 'trap failure' text at locations where they occurred and draw spray arrows
    # start by defining kwargs for textbox and spray arrow
    text_kwargs = dict(rotation='vertical', color='blue',
                       fontweight='bold', horizontalalignment='center', verticalalignment='bottom')
    annotate_kwargs = dict(xytext=(0, 150), textcoords='offset pixels',
                           arrowprops=dict(arrowstyle='simple', connectionstyle="arc3",
                                           facecolor='black', edgecolor='none'),
                           rotation='vertical', color='blue', fontweight='bold',
                           horizontalalignment='center', verticalalignment='bottom')

    if two_days == 'n':
        for p in problems1:  # add problems text
            if p['x'] in spray_sites1:  # shift text up if a spray arrow is being drawn
                p['y'] += data_max / 21
            ax.text(tick_dict[p['x']], p['y'], p['text'], **text_kwargs)

        for s in spray_sites1:  # add spray arrows
            ax.annotate('', xy=(tick_dict[s], spray_y1[s]), **annotate_kwargs)

    elif two_days == 'y':
        for p in problems1:
            if p['x'] in spray_sites1:
                p['y'] += data_max / 21
            # change alignment from center to make room for second date
            text_kwargs['horizontalalignment'] = 'right'
            ax.text(tick_dict[p['x']]-0.03, p['y'], p['text'], **text_kwargs)
        for p in problems2:
            if p['x'] in spray_sites2:
                p['y'] += data_max / 21
            # change alignment and color of text for second date
            text_kwargs['horizontalalignment'] = 'left'
            text_kwargs['color'] = 'red'
            ax.text(tick_dict[p['x']]+0.03, p['y'], p['text'], **text_kwargs)

        for s in spray_sites1:
            annotate_kwargs['horizontalalignment'] = 'right'
            ax.annotate('', xy=(tick_dict[s] - .175, spray_y1[s]), **annotate_kwargs)
        for s in spray_sites2:
            annotate_kwargs['horizontalalignment'] = 'left'
            ax.annotate('', xy=(tick_dict[s] + .175, spray_y2[s]), **annotate_kwargs)

    # based on weather, add icons to graph and shift temperature text to accomodate icons (this gets hacky)
    precip_column = 'A'  # determines which column to draw the rain icon if that date wasn't also windy
    text_bumper, newline = '', ''
    string_list = []
    color_list = ['blue']

    weather1 = get_weather(month1, day1, year=year)
    if two_days == 'y':
        weather2 = get_weather(month2, day2, year=year)

    if two_days == 'y':
        # if either date was windy and rainy, add a string to shift the text to accomodate both icons
        if weather1['wind'] + weather1['precip'] == 2 or weather2['wind'] + weather2['precip'] == 2:
            text_bumper = '   '  # three spaces
    elif two_days == 'n':
        # add bumper to shift text if it was both windy and rainy
        if weather1['wind'] + weather1['precip'] == 2:
            text_bumper = '   '  # three spaces

    # if day 1 was windy and rainy, but day 2 was only rainy, this draws the rain icons in the same column
    # if day 1 was windy only, and day two was rainy only, this draws the wind and rain icon in the same column instead
    if two_days == 'y':
        # sum(weather) is only >= 3 if at least one day had both wind and rain
        weather_sum = sum([weather1['wind'], weather1['precip'], weather2['wind'], weather2['precip']])
        if weather_sum >= 3:
            precip_column = 'B'

    # draw icons for day 1
    if weather1['wind'] + weather1['precip'] == 2:  # wind and precipitation
        weather_icon('wind', 'A', 1)
        weather_icon('rain', 'B', 1)
    elif weather1['wind'] == 1 and weather1['precip'] == 0:
        weather_icon('wind', 'A', 1)
    elif weather1['wind'] == 0 and weather1['precip'] == 1:
        weather_icon('rain', precip_column, 1)
    # add text to weather legend
    string_list.append(text_bumper + 'Temp: {}/{}°F'.format(weather1['high'], weather1['low']))

    if two_days == 'y':
        # add weather for day 2
        if weather2['wind'] + weather2['precip'] == 2:  # wind and precipitation
            weather_icon('wind', 'A', 2)
            weather_icon('rain', 'B', 2)
        elif weather2['wind'] == 1 and weather2['precip'] == 0:
            weather_icon('wind', 'A', 2)
        elif weather2['wind'] == 0 and weather2['precip'] == 1:
            weather_icon('rain', precip_column, 2)

        # add a second row to weather legend
        newline = '\n'
        # add text to aforementioned row and a color to render it in
        string_list.append(text_bumper + 'Temp: {}/{}°F'.format(weather2['high'], weather2['low']))
        color_list.append('red')

    # draw the box for the weather legend
    # coords in annotate and rainbow_text optimized for .jpg/.pdf, will look whack in matplot preview
    # annotate text determines size of box, but is rendered in white
    ax.annotate(newline + text_bumper + '    Temp: 100/10°F', xy=(1.01, 0.42), color='white', xycoords='axes fraction',
                bbox=dict(facecolor='none', edgecolor='lightgrey', boxstyle='round'),
                verticalalignment='top', horizontalalignment='left')
    # write the actual text onto the box
    rainbow_text(1.022, 0.420, string_list, color_list)

    # add graph legend and title, and adjust the graph
    legend_bbox = (1, 0.5)
    ax.legend(loc='center left', bbox_to_anchor=legend_bbox)
    plt.title('CO2 Trap Locations', fontsize='15', fontweight='bold')
    plt.subplots_adjust(bottom=0.15)  # move the bottom of the graph so x labels are not cut off

    # add text describing purpose of aerial application arrows if either spray list is not empty
    if spray_sites1 or spray_sites2:
        ax.annotate('Arrows indicate trap\n'
                    'location was treated\n'
                    'by aerial adulticide.',
                    xy=(1.01, 0.25), color='black', xycoords='axes fraction', fontsize=6,
                    bbox=dict(facecolor='none', edgecolor='lightgrey', boxstyle='round'),
                    verticalalignment='bottom', horizontalalignment='left')

    if note == 'y':
        ax.annotate(note_text,
                    xy=(1.01, note_y), color='black', xycoords='axes fraction', fontsize=6,
                    bbox=dict(facecolor='none', edgecolor='lightgrey', boxstyle='round'),
                    verticalalignment='bottom', horizontalalignment='left')

    # save a copy of the graph and then open it
    plt.savefig('most_recent.jpg', dpi=1000, bbox_inches='tight')
    im = Image.open('most_recent.jpg')
    im.show()
    print('\nGraph completed.\n')

    # ask the user if they want to save
    """# save .jpg to Google drive
    g_drive_save = get_xy('Would you like to save the graph to the Google Drive? y/n\n')
    if g_drive_save == 'y':
        try:
            im.save('G:\\My Drive\\C02.jpg')
        except FileNotFoundError:
            print('Google Drive not accessible from this computer.')"""
    # save a .pdf to the lab folder
    pdf_save = get_xy('Would you like to save a .pdf copy? y/n\n')
    # format file name
    if pdf_save == 'y':
        if pre == 'y':
            pre_tag = '(Pre)'
        else:
            pre_tag = "(Final)"
        if two_days == 'y':
            mo = month2
            da = date2
        else:
            mo = month1
            da = date1
        pdf_out = graph_pdf_directory+'{}\\{} {}.pdf'.format(mo, da.strftime('%d %b %Y'), pre_tag)
        im.save(pdf_out)
    print('\nComplete!')


def make_gravid_graph(year=year):
    """
    This function is similar to make_graph(). The function creates a graph of Culex abundance for gravid trap sites.
    The graph will show data for three dates. There are two separate gravid trap routes, one set on Monday and one set
    on Wednesday. The user will be asked which route. There is no option for preliminary vs. final graphs.
    """

    # # # sub-functions # # #
    def weather_icon(icon, column, row):
        """
        Draws the icon to the weather legend at (column, row).
        """

        imagebox = OffsetImage((matplotlib.image.imread(icon + '.png')), zoom=0.5)

        c = {'A': 1.0152, 'B': 1.028}
        r = {1: 0.408, 2: 0.375, 3: 0.342}
        ab = AnnotationBbox(imagebox, (c[column], r[row]), xycoords='axes fraction', frameon=False)
        ax.add_artist(ab)

    def rainbow_text(x, y, ls, lc, **kw):
        """
        Take list of strings (ls) and list of colors (lc), and render each strings as the corresponding color.

        x,y should be in axes fraction coords
        """
        t = plt.gca().transData
        fig = plt.gcf()
        data_to_axis = ax.transAxes + ax.transData.inverted()
        new_xy = data_to_axis.transform([x, y]).tolist()
        x, y = new_xy[0], new_xy[1]
        # horizontal version

        for s, c in zip(ls, lc):
            text = plt.text(x, y, " " + s + " ", color=c, transform=t,
                            verticalalignment='top', horizontalalignment='left', **kw)
            text.draw(fig.canvas.get_renderer())
            ex = text.get_window_extent()
            t = transforms.offset_copy(text._transform, y=-ex.height * 13.5, units='dots')

    year = year
    # open a read-only .xlsx workbook as the source of input data
    wb = load_workbook(filename=mosquito_count, data_only=True, read_only=True)
    ws = wb['Gravid Data']
    series1 = []
    series2 = []
    series3 = []
    problems1 = []
    problems2 = []
    problems3 = []

    # ask user what dates to graph
    month1 = get_month("Enter first month:\n")
    day1 = get_day("Enter first day:\n")
    date1 = datetime.datetime(int(year), int(month1), int(day1))

    month2 = get_month("Enter second month:\n")
    day2 = get_day("Enter second day\n")
    date2 = datetime.datetime(int(year), int(month2), int(day2))

    month3 = get_month("Enter third month:\n")
    day3 = get_day("Enter third day\n")
    date3 = datetime.datetime(int(year), int(month3), int(day3))

    dates = [date1, date2, date3]
    series = [series1, series2, series3]
    problems = [problems1, problems2, problems3]

    # ask the user which route is being graphed to select the correct site names
    mw = get_xy(prompt='Which gravid route will be graphed?\n'
                       'm = Monday Route\n'
                       'w = Wednesday Route\n', x='m', y='w')
    if mw == 'm':
        route = mon_sites
        ticks = mon_ticks
    elif mw == 'w':
        route = wed_sites
        ticks = wed_ticks

    # find which column contains 'comments'
    for i in range(30):
        if ws.cell(row=1, column=i + 1).value == 'comments':  # ws.cell() starts index at 1, hence i+1 (yuck)
            com_index = i  # but index of 'row' in ws.iter_rows() below starts at 0

    # iterate over rows in workbook to find dates of interest, then add count values to series lists if matched
    for row in ws.iter_rows(min_row=2, max_col=25, max_row=10000, values_only=True):
        for cell in row:
            for i in range(3):  # loop once for each date
                if cell == dates[i]:
                    if row[17] is None:  # row[17] == 'total_culex_f' column
                        y = 0
                    else:
                        y = row[17]
                    series[i].append(y)
                    # if trap failed or wasn't set, add text to problems list
                    if row[com_index] is not None and row[com_index].startswith('text:') is True:
                        problems[i].append([row[1], y, row[com_index].replace('text:', '')])
                    elif row[3] == 'not set':
                        problems[i].append([row[1], y, 'Not Set'])
                    elif row[3] is not None:
                        problems[i].append([row[1], y, 'Trap Failure'])

    # begin defining graph parameters
    matplotlib.rcParams['font.family'] = 'serif'
    matplotlib.rcParams['mathtext.fontset'] = 'custom'
    matplotlib.rcParams['mathtext.bf'] = 'STIXGeneral:italic:bold'
    matplotlib.rcParams['font.size'] = 7
    x = (np.arange(len(route)))

    plt.figure(figsize=(10, 5))
    ax = plt.subplot()
    ax.set_axisbelow(True)  # draw gridlines under bars
    ax.yaxis.grid(True, which='major', color='grey', alpha=.25)

    # add series to graphs
    width = 0.2
    rect1 = ax.bar(x - width, series1, width, label=date1.strftime("%d-%b-%Y"), color='green')
    rect2 = ax.bar(x, series2, width, label=date2.strftime("%d-%b-%Y"), color='orange')
    rect3 = ax.bar(x + width, series3, width, label=date3.strftime("%d-%b-%Y"), color='red')

    # label x axis & ticks
    ax.set_xticks(x)
    ax.set_xticklabels(ticks, rotation=90, ha='center')
    tick_dict = {}
    for i in range(len(route)):
        tick_dict[route[i]] = x[i]

    # label y axis
    plt.ylabel(r"No. female $\bf{Culex}$ trapped", fontweight='bold')  # render 'Culex' in italics

    # add 'not set' and 'trap failure' text at locations where they occurred
    for p in problems1:
        ax.text(tick_dict[p[0]] - 0.15, p[1], p[2], rotation='vertical', color='green',
                fontweight='bold',
                horizontalalignment='right', verticalalignment='bottom')
    for p in problems2:
        ax.text(tick_dict[p[0]], p[1], p[2], rotation='vertical', color='orange',
                fontweight='bold',
                horizontalalignment='center', verticalalignment='bottom')
    for p in problems3:
        ax.text(tick_dict[p[0]] + 0.15, p[1], p[2], rotation='vertical', color='red',
                fontweight='bold',
                horizontalalignment='left', verticalalignment='bottom')

    # based on weather, add icons to graph
    weather1 = get_weather(month1, day1, year=year)
    wp1 = weather1['wind'] + weather1['precip']
    weather2 = get_weather(month2, day2, year=year)
    wp2 = weather2['wind'] + weather2['precip']
    weather3 = get_weather(month3, day3, year=year)
    wp3 = weather3['wind'] + weather3['precip']

    weather = [weather1, weather2, weather3]

    precip_column = 'A'  # determines which column to draw the rain icon if that date wasn't also windy
    text_bumper = ''
    string_list = []
    color_list = ['green', 'orange', 'red']

    # if any date was windy and rainy, add a string to shift the text to accomodate both icons
    if wp1 == 2 or wp2 == 2 or wp3 == 2:
        text_bumper = '   '  # three spaces
        precip_column = 'B'

    # add weather icons
    for i in range(3):
        if weather[i]['wind'] + weather[i]['precip'] == 2:
            weather_icon('wind', 'A', i+1)
            weather_icon('rain', 'B', i+1)
        elif weather[i]['wind'] == 1 and weather[i]['precip'] == 0:
            weather_icon('wind', 'A', i+1)
        elif weather[i]['wind'] == 0 and weather[i]['precip'] == 1:
            weather_icon('rain', precip_column, i+1)

    # add text to weather legend
    string_list.append(text_bumper + 'Temp: {}/{}° F'.format(weather1['high'], weather1['low']))
    string_list.append(text_bumper + 'Temp: {}/{}° F'.format(weather2['high'], weather2['low']))
    string_list.append(text_bumper + 'Temp: {}/{}° F'.format(weather3['high'], weather3['low']))


    # draw the box for the weather legend
    # text determines size of box, but is rendered in white
    ax.annotate('\n\n      Temp: 100/10° F', xy=(1.01, 0.42), color='white', xycoords='axes fraction',
                bbox=dict(facecolor='none', edgecolor='lightgrey', boxstyle='round'),
                verticalalignment='top', horizontalalignment='left')

    # write the actual text onto the box
    rainbow_text(1.022, 0.420, string_list, color_list)

    # add legend, title, and adjust the graph
    legend_bbox = (1, 0.5)
    ax.legend(loc='center left', bbox_to_anchor=legend_bbox)
    plt.title('Gravid Trap Locations', fontsize='15', fontweight='bold')
    plt.subplots_adjust(bottom=0.15)  # move the bottom of the graph so x labels are not cut off

    # ask the user if they want to save
    # if so, save a jpg to the google drive and a pdf to the weekly graph folder
    plt.savefig('most_recent.jpg', dpi=1000, bbox_inches='tight')
    im = Image.open('most_recent.jpg')
    im.show()
    print('\nGraph completed.\n')
    """if input('Would you like to save the graph to the Google Drive? y/n\n') == 'y':
        if mw == 'm':
            img_name = "Gravid1"
        elif mw == 'w':
            img_name = "Gravid2"
        im.save('G:\\My Drive\\{}.jpg'.format(img_name))"""
    if input('Would you like to save a .pdf copy? y/n\n') == 'y':
        g_pdf = 'G' + date3.strftime('%#m%d')
        im.save(gravid_graph_pdf_directory+'{}.pdf'.format(g_pdf))
    print('\nComplete!')


def make_stacked_graph(trap_type, year=year):
    """
    create a stacked bar graph to show species abundance
    """

    year = year
    # open a read-only .xlsx workbook as the source of input data
    wb = load_workbook(filename=mosquito_count, data_only=True,read_only=True)
    trap_sheets = ['City CO2 Data', 'BGS Data']
    # ask user what to graph
    dates = []
    ws = wb[trap_sheets[trap_type]]
    # City CO2 is 0, BGS is 1
    if trap_type == 0:
        two_days = 'y'
        stack_ticks = city_ticks
        stack_sites = city_sites
    if trap_type == 1:
        two_days = 'n'
        route = get_int("Select a BGS route\n"
                        "0 = City Route\n"
                        "1 = Industrial Route\n", 0, 1)
        if route == 0:
            stack_ticks = bgs_city_sites
            stack_sites = bgs_city_sites
        elif route == 1:
            stack_ticks = bgs_ind_sites
            stack_sites = bgs_ind_sites

    if two_days == 'y':
        month1 = get_month("Enter first month:\n")
        day1 = get_day("Enter first day:\n")
        dates.append(datetime.datetime(int(year), int(month1), int(day1)))
        month2 = get_month("Enter second month:\n")
        day2 = get_day("Enter second day\n")
        dates.append(datetime.datetime(int(year), int(month2), int(day2)))
    elif two_days == 'n':
        month1 = get_month()
        day1 = get_day()
        dates.append(datetime.datetime(int(year), int(month1), int(day1)))


    # find the number of columns containing individual mosquito species counts
    mosq_columns = []
    non_mosq = ['date', 'location', 'total', 'problems']
    for i in range(1, len(ws[1])+1):
        if trap_type == 1:  # if bgs
            if '_m' in ws[1][i].value:  # ignore the columns containing male counts
                continue
        if ws[1][i].value not in non_mosq and ws[1][i].value != 'comments':
            mosq_columns.append(i)
        elif ws[1][i].value == 'comments':
            break
    series = []
    problems = []
    # create a sub-series list within series for each different mosquito species
    for s in mosq_columns:
        series.append([])

    # iterate over rows in workbook to find dates of interest, then add count values to 'series' lists if matched
    for row in ws.iter_rows(min_row=2, max_col=25, max_row=10000, values_only=True):
        if row[0] in dates:
            y = 0  # total height of sub-series
            if row[2] is None or row[2] == 0 or row[3] == 'not set':  # if the trap was empty, set all sub-series to 0
                for s in range(len(mosq_columns)):
                    series[s].append(0)
            else:
                # iterate over the cells containing species counts to calculate subtotal
                sub_total = 0
                for s in mosq_columns:
                    count = row[s]
                    if count is None:
                        sub_total += 0
                    else:
                        sub_total += count

                # iterate again to scale counts based on the ratio between total and subtotal
                f = 1
                t = 0
                if sub_total > 0:
                    f = row[2] / sub_total
                for s in range(len(mosq_columns)):
                    val = row[mosq_columns[s]]
                    if val is None:
                        val = 0

                    series[s].append(int(val * f))
                    y += int(val * f)

            # if trap failed or wasn't set, add text to problems list saying so
            if row[3] == 'not set':
                problems.append([row[1], y, 'Not Set'])
            elif row[3] is not None:
                problems.append([row[1], y, 'Trap Failure'])

    # begin defining graph parameters
    matplotlib.rcParams['font.family'] = 'serif'
    matplotlib.rcParams['font.size'] = 7

    # make bars narrower if two days are being graphed
    plt.figure(figsize=(10, 5))
    ax = plt.subplot()
    # gridlines
    ax.set_axisbelow(True)  # draw gridlines under bars
    ax.yaxis.grid(True, which='major', color='grey', alpha=.25)

    # add series to graphs
    width = 0.4
    bot = np.zeros(len(series[0]))

    cd = {'dorsalis': '#4e79a7', 'nigromaculis': '#b07aa1', 'sierrensis': '#a0cbe8',
          'vexans': '#59a14f', 'freeborni': '#959c9e', 'erythrothorax': '#f28e2a',
          'pipiens': '#f0be27', 'tarsalis': '#e15759', 'incidens': '#d7b5a6',
          'inornata': '#9d7660', 'increpitus': '#ff9d9a', 'perturbans': '#32cf78'}
    if trap_type == 0:
        colors = [cd['pipiens'], cd['tarsalis'], cd['erythrothorax'], cd['dorsalis'],
                  cd['increpitus'], cd['nigromaculis'], cd['vexans'], cd['sierrensis'],
                  cd['freeborni'], cd['inornata'], cd['incidens'], cd['perturbans']]
    elif trap_type == 1:
        colors = [cd['pipiens'], cd['incidens'], cd['tarsalis'], cd['inornata'],
                  cd['sierrensis'], cd['dorsalis'], cd['vexans']]

    x = (np.arange(len(stack_sites)))
    for s in range(len(series)):
        if sum(series[s]) != 0:
            ax.bar(x, series[s], width, bottom=bot, color=colors[s])
            bot += series[s]

    # label x axis & ticks
    ax.set_xticks(x)
    ax.set_xticklabels(stack_ticks, rotation=0, ha='center')
    tick_dict = {}
    for i in range(len(stack_sites)):
        tick_dict[stack_sites[i]] = x[i]

    # label y axis6+
    plt.ylabel('No. female mosquitoes trapped', fontweight='bold')

    # add 'not set' and 'trap failure' text at locations where they occurred
    for p in problems:
        ax.text(tick_dict[p[0]], p[1], p[2], rotation='vertical', color='black',
                fontweight='bold',
                horizontalalignment='center', verticalalignment='bottom')

    # add legend, title, and adjust the graph
    legend_bbox = (1, 1)

    # pull species names from input sheet and remove labels for each species sub-series without any mosquitoes
    raw_labels = [ws[1][s].value for s in mosq_columns]
    excluded_labels = []
    for i in range(len(series)):
        if sum(series[i]) == 0:
            excluded_labels.append(raw_labels[i])
    for i in excluded_labels:
        if i in raw_labels:
            raw_labels.remove(i)

    # reformat labels (e.g 'culex_pipiens_f' to 'Culex pipiens'[in italics])
    labels = ["$\\it{" + i.replace('_', "}$ $\\it{", 1).replace('_f', '}$', 1).capitalize()
              for i in raw_labels]
    ax.legend(labels=labels, loc='upper left', bbox_to_anchor=legend_bbox)
    if trap_type == 0:
        plt.title('City CO2 Species Abundance\n{}-{}'.format(dates[0].strftime('%#d'), dates[1].strftime('%#d %B %Y')),
                  fontsize='13', fontweight='bold')
    elif trap_type == 1:
        plt.title('BGS Species Abundance\n{}'.format(dates[0].strftime('%#d %B %Y')),
                  fontsize='13', fontweight='bold')

    # adjust the y-limit to be 5% taller
    bottom, top = plt.ylim()
    top += (top * 0.05)
    plt.ylim(top=top)

    plt.subplots_adjust(bottom=0.15)  # move the bottom of the graph so x labels are not cut off

    # ask the user if they want to save
    # if so, save a jpg to the google drive and a pdf to the weekly graph folder
    plt.savefig('most_recent.jpg', dpi=1000, bbox_inches='tight')
    im = Image.open('most_recent.jpg')
    im.show()
    if input('Would you like to save a .pdf copy? y/n\n') == 'y':
        im = Image.open('most_recent.jpg')
        if trap_type == 0:
            g_pdf = 'City CO2 Species {}-{}'.format(dates[0].strftime('%#d'), dates[1].strftime('%#d %B %Y'))
        elif trap_type == 1:
            g_pdf = 'BGS Species {}'.format(dates[0].strftime('%#d %B %Y'))
        im.save(city_graph_pdf_directory+'{}.pdf'.format(g_pdf))
    print('\nGraph completed.')
    print('\nComplete!')


def andrive():
    """
    pull trap data from mosquito count sheet and format it for uploading to ArcGis trap dashboard
    """

    # open a read-only .xlsx workbook as the source of input data
    wb = load_workbook(filename=mosquito_count, data_only=True,read_only=True)
    ws = wb['CO2 Data']

    # find index of columns which contain mosquito counts
    mosq_columns = 4  # starts at 4 to offset preceding columns containing date, location, total, problems
    non_mosq = ['date', 'location', 'total', 'problems']
    for cell in ws[1]:
        if cell.value not in non_mosq and cell.value != 'comments':
            mosq_columns += 1
        elif cell.value == 'comments':
            break

    # set-up field names and add them the the list of rows to be written to the .csv file
    header = ['date', 'location', 'x', 'y', 'total', 'problems']
    for cell in ws[1][4:mosq_columns]:
        header.append(cell.value)
    rows = [header]

    # find the most recent date in the input file
    dates = []
    for row in ws.iter_rows(min_row=2, max_col=1, values_only=True):
        for cell in row:
            if cell is not None:
                dates.append(cell)
    latest = max(dates)
    print("Latest date detected: {}".format(latest.strftime("%m/%d/%Y")))

    # iterate over file to find entries that match most recent date
    for row in ws.iter_rows(min_row=2, max_col=25, max_row=10000, values_only=True):
        if row[0] == latest:
            # this list holds the data for the new row that will be written to the dashboard drive
            w = [row[0].strftime("%m/%d/%Y"), row[1], coords[row[1]][0], coords[row[1]][1], row[2], row[3]]

            # if trap was empty, skip converting counts
            if row[2] == 0 or row[2] is None:
                rows.append(w)
            # otherwise convert counts
            else:
                # first, iterate over the cells containing mosquito counts to calculate subtotal
                sub_total = 0
                for count in row[4:mosq_columns]:
                    if count is None:
                        sub_total += 0
                    else:
                        sub_total += count

                # iterate again to scale counts based on the ratio between total and subtotal
                f = 1
                t = 0
                if sub_total > 0:
                    f = row[2] / sub_total
                for count in row[4:mosq_columns]:
                    if count is None:
                        count = 0
                    w.append(int(count * f))
                    t += int(count * f)
                # append new row (w) to the list of rows to write to the .csv
                rows.append(w)

    # create drive file
    file = andrive_out_csv
    with open(file, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        for row in rows:
            writer.writerow(row)
    print('\nComplete!')


def vecsurv(month, day, trap_type):
    """
    pull trap data from the mosquito count sheet and format it for uploading to VectorSurv
    """

    # open a read-only .xlsx workbook as the source of input data
    wb = load_workbook(filename=mosquito_count, data_only=True,read_only=True)
    sheets = ('CO2 Data', 'Gravid Data', 'City CO2 Data', 'BGS Data')
    trap_code = ('CO2', 'GRVD', 'CO2', 'BGSENT')
    ws = wb[sheets[trap_type]]  # select a workbook sheet based on trap type

    # find the index for columns which contain mosquito counts
    mosq_columns = 4  # start at 4 to offset the non-mosquito columns that precede mosquito species counts (e.g. date)
    non_mosq = ['date', 'location', 'total', 'problems']
    for cell in ws[1]:
        if cell.value not in non_mosq and cell.value != 'comments':
            mosq_columns += 1
        elif cell.value == 'comments':
            break

    # set-up field names and add them the the list of rows to be written to the .csv file
    field_names = ['agency', 'trap_type', 'collection_date', 'nights', 'site', 'problem', 'comments']
    for cell in ws[1][4:mosq_columns]:
        field_names.append(cell.value)
    csv_rows = [field_names]

    # iterate over rows in workbook to find date of interest
    count_validation = []  # this list will be printed so the user may verify the math was correct
    for row in ws.iter_rows(min_row=2, max_col=25, max_row=10000, values_only=True):
        if row[0] == datetime.datetime(int(year), int(month), int(day)):
            if row[3] != 'not set':  # check that trap was actually set
                # adjust the date the trap was set to date it was collected and convert to string
                col_date = datetime.timedelta(days=1) + row[0]
                date_string = col_date.strftime("%Y-%m-%d")

                # this list holds the data for the new row that will be written to the .csv
                w = ['SLCM', trap_code[trap_type], date_string, 1, ID[row[1]], 'N', row[3]]

                # if input contained data in problems column, set problem to 'Y'
                if row[3] is not None:
                    w[5] = 'Y'

                # if trap was empty, append w to .csv as is
                if row[2] == 0 or row[2] is None:
                    csv_rows.append(w)
                # otherwise adjust counts from the counted sub-total to the estimated total
                else:
                    # first, iterate over the cells containing mosquito counts to calculate subtotal
                    sub_total = 0
                    for count in row[4:mosq_columns]:
                        if count is None:
                            sub_total += 0
                        else:
                            sub_total += count

                    # iterate again, this time scaling counts based on the ratio between total and subtotal
                    f = 1  # the fractional ratio of total to subtotal (defaults to 1 to prevent division by zero)
                    t = 0  # this is the sum of scaled up species counts
                    # it should approximate the actual total, but will be slightly off due to rounding
                    if sub_total > 0:
                        f = row[2]/sub_total
                    for count in row[4:mosq_columns]:
                        if count is None:
                            count = 0
                        w.append(int(count*f))
                        t += int(count*f)
                    # add the actual total and 't' to list which will be printed for user to verify accurate conversion
                    count_validation.append((t, row[2]))

                    # append new row (w) to the list of rows to write to the .csv
                    csv_rows.append(w)

    # write the .csv file
    filename = '{}{}_{}_{}_{}.csv'.format(vecsurv_out_directory, trap_code[trap_type], year, month, day)
    if trap_type == 2:
        filename = '{}CityCO2_{}_{}_{}.csv'.format(vecsurv_out_directory, year, month, day)

    # write rows to .csv
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        for row in csv_rows:
            writer.writerow(row)
    print(count_validation)
    print('\nComplete!')


def tableau():
    # open a read-only .xlsx workbook as the source of input data
    wb = load_workbook(filename=mosquito_count, data_only=True,read_only=True)
    sheets = ('CO2 Data', 'Gravid Data', 'City CO2 Data', 'BGS Data')
    trap_code = ('CO2', 'GRVD', 'CO2', 'BGSENT')

    # list for holding rows
    rows_to_write = [['date', 'site', 'latitude', 'longitude', 'species', 'count', 'trap_type', 'problems']]

    for trap_type in range(0, 3):
        ws = wb[sheets[trap_type]]  # select a workbook sheet based on trap type
        # find the index for columns which contain mosquito counts
        mosq_columns = 4  # start at 4 to offset the non-mosquito columns that precede mosquito species counts (e.g. date)
        non_mosq = ['date', 'location', 'total', 'problems']
        for cell in ws[1]:
            if cell.value not in non_mosq and cell.value != 'comments':
                mosq_columns += 1
            elif cell.value == 'comments':
                break

        for row in ws.iter_rows(min_row=2, max_col=25, values_only=True):
            if row[2] == 0 or row[2] is None:  # skip blank lines and empty traps
                continue
            if row[0] is not None:
                date = datetime.datetime.strftime(row[0], '%m/%d/%Y')
                site = row[1]
                longitude, latitude = coords[site][0], coords[site][1]
                trap = trap_code[trap_type]
                if row[3] is not None and row[3] != 'not set':
                    problem = 'Y'
                else:
                    problem = 'N'

                # first, iterate over the cells containing mosquito counts to calculate subtotal
                sub_total = 0
                print('row({})'.format(row))
                for count in row[4:mosq_columns]:
                    if count is None:
                        sub_total += 0
                    elif type(count) is int:
                        sub_total += count

                # iterate again, this time scaling counts based on the ratio between total and subtotal
                f = 1  # the fractional ratio of total to subtotal (defaults to 1 to prevent division by zero)
                t = 0
                if sub_total > 0:
                    f = row[2] / sub_total
                col_index = 5
                for count in row[4:mosq_columns]:
                    if count is None:
                        col_index += 1
                        continue
                    else:
                        # create species name by finding column header and converting from "genus_species_f" to "Genus species"
                        header = ws.cell(row=1, column=col_index).value
                        species = header.capitalize().replace("_", " ", 1).replace("_f", "")
                        col_index += 1
                        num = int(count * f)
                        t += num
                        rows_to_write.append([date, site, latitude, longitude, species, num, trap, problem])
            print(t, row[2])

    # write rows to .csv
    with open('tableau.csv', 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        for row in rows_to_write:
            writer.writerow(row)
    print('\nComplete!')


# # # interface loop# # #
close = False
while close is False:
    process = get_int('\nWhat would you like to do?\n'
                      '0 = Create a graph\n'
                      '1 = Create VectorSurv import form\n'
                      '2 = Update the trap dashboard data\n'
                      '3 = Update Tableau\n'
                      '4 = Exit\n', 0, 4)
    if process == 0:
        print('\nRunning graph maker...')
        graph_type = get_int('Select a trap type:\n'
                             '0 = CO2\n'
                             '1 = Gravid\n'
                             '2 = City CO2\n'
                             '3 = BGS\n', 0, 3)
        if graph_type == 0:
            make_graph()
        elif graph_type == 1:
            make_gravid_graph()
        elif graph_type == 2:
            make_stacked_graph(0)
        elif graph_type == 3:
            make_stacked_graph(1)
    elif process == 1:
        print('\nRunning VectorSurv converter...')
        vecsurv(trap_type=get_int('Select trap type:\n0 = CO2\n1 = Gravid\n2 = City CO2\n3 = BGS\n', 0, 3),
                month=get_month(), day=get_day())
    elif process == 2:
        print('\nRunning trap dashboard updater...')
        andrive()
    elif process == 3:
        print('\nRunning Tableau updater...')
        tableau()
    elif process == 4:
        print("Goodbye.")
        close = True
